#Part 1a:

1. 'values added: 20' is returned.
2. 'final result: 20' is returned.
3. 'values added: 20' is returned.
4. We get an error saying that we have a ReferenceError: 'result is not defined'. This happens due to the let keyword, our result variable is only accessible from within the if statement it was defined in and therefore when we try to call this result variable again directly outside of the if statement it is no longer in scope and so we get an error for it not being defined.
5. We get a TypeError due to 'Assignment to constant variable'. This happens due to the fact that our result variable is now a const type meaning it is a constant and can not be changed so when the program tries to change it, it throws the TypeError error.
6. Assuming that the error at line 7 is caught and we make it to line 13 we would run into the same error as question #4 where our result variable is out of scope. This happens because the const keyword also lives within the block scope just like the let keyword does. The exact error we would get is the ReferenceError: 'result is not defined' and as said prior this is due to result being out of scope when it is called here.
---

#Part 1b:
1. At line 12 the last stored value of variable i will be printed out to the console. In this case '3'. This happens due to the fact that the variable i is declared using the var keyword which puts its scope as the entire discountPrices function. 
2. At line 13 the last stored value of the variable discountedPrice will be printed out to the console. In this case it will be '150' since the value '300' is the last item in the prices array and as such the last thing to be calculated within the for loop starting at line 6. Similar to the variable i, variable discountedPrice was also declared using the var keyword and so it has a scope of the entire function which is why it is still accessible even though it was declared within the for loop.
3. At line 14 the last stored value of the variable finalPrice will be printed out to the console. In this case it will be '150'. Again just like the variables discounted and discountedPrice, finalPrice has a scope of the entire function due to being declared with the var keyword. finalPrice is meant to round up the discountedPrice value however since the values are only in whole dollars currently it is exactly the same value as discountedPrice. 
4. The entire function of discountPrices would return our discounted array. In this case '[50,100,150]' which is the finalPrice for each element of the passed in prices array. This array named discounted is also declared using the var keyword and as such its scope is the entire function just like the other variables. Due to this it is pushed to during each iteration of the for loop which adds each respective finalPrice after applying the discount to each passed in value from the prices paramater. 
5. At line 12 there will be a ReferenceError. This happens because the variable i was declared using the let keyword which causes its scope to only be within the for loop and so when it is called outside of the for loop that variable does not exist and that is why we get the ReferenceError. 
6. At line 13 there will be a ReferenceError. Similar to the variable i, variable discountedPrice is declared using the let keyword within the scope of the for loop and therefore it is not accessible outside of the for loop. When the program calls discountedPrice on line 13 that is outside of the scope of the for loop and so we get a ReferenceError since there is no variable discountedPrice within that scope. 
7. At line 14 the last stored value of the variable finalPrice will be printed out to the console. In this case that is '150'. This happens because even though our variable is declared using the let keyword it was declared at the beginning of the function and therefore its scope is the entire function which allows us to use it throughout and then print it out as is done on line 14.
8. The function still runs with the same output as before when all variables were declared with var instead of let. The output is '[ 50, 100, 150 ]'. The reason why this still works is because even though the variable discounted is declared using the let keyword here it still has a scope the size of the function. The variable finalPrice also has this same scope. The other variables, i and discountedPrice are declared with let as well however their scopes fall only within the for loop. The reason why this function still works even with those variables having a smaller scope is that the main part that uses them falls within the for loop and therefore our overall function will run just fine and output the correct values. 
9. At line 11 we will run into the ReferenceError again. This is due to the fact that our variable i was declared using the let keyword and therefore its scope is only within the for loop. When it is called on line 11 no variable named i exists in that scope and so we get the ReferenceError.
10. At line 12 we will see the value of length being printed to the console. In this case '3'. This happens due to the fact that even though the variable length was declared using the const keyword, which has the same sort of block scope as let, it was done so at the beginning of the function and so it still has a scope of the function. 
11. The function overall will run just as it has the other 2 times and will output the following '[ 50, 100, 150 ]'. Even though our variables discounted, length and discountedPrice are all decalred using the const keyword and thus have a smaller scope then a var, they still have enough scope with regards to where they are used in the function to run properly. For example, discountedPrice is declared within the for loop which works perfectly due to the fact that it is the only place it is ever called for. Likewise, the only variable that is called outside of the for loop has a scope of the entire function due to it being declared at the beginning of the function even though it is declared using the const keyword. 
12. The notation requested for each part is as follows:
    A. `student.name;`
    B. `student['Grad Year'];`  
    C. `student.greeting();`
    D. `student['Favorite Teacher'].name;`
    E. `student.courseLoad[0]`
13. Arithmetic
    A. '32', that output is given since integers map to their exact string representation. The number 2 will become a string and be appended to the current string of '3'. 
    B. 1, that output is given due to the fact that you can't subtract 2 from a string and so the string is converted into a numberical value, in this case the direct value that is within of 3 and then the subtraction takes place.
    C. 3, that output is given due to the fact that null becomes 0 via type conversion because of the presence of the + operator. Therefore 3 + 0 is 3.
    D. '3null', that output is given due to the fact that '3' is there and so instead of type converting null into 0 like above because there is a string present null will instead just be appended to the current string.
    E. 4, that output is given due to the fact that true becomes 1 due to the presence of a + operator. After that conversion it is simply 1 + 3 = 4. 
    F. 0, that output is given due to the fact that both false and null are converted to 0 and so 0 + 0 = 0.
    G. '3undefined', that output is given due to the fact that there is a string and so the other value is just appended to said string thus giving us that '3' + undefinted = '3undefined'
    H. NaN, that output is given due to the fact that when converted into a number undefined becomes NaN and that will then be the result of any operation against it. After the conversion the equation becomes '3' - NaN = NaN.
14. Comparison
    A. true, string '2' will be converted into a number for this comparison and then 2 > 1 would return true.
    B. false, due to their being 2 different strings it seems like instead of converting both into their numerical values instead the first character of both strings is compared which ends up checking if 2 < 1 which ends up giving us the false.
    C. true, string '2' will be converted into a number since there is a number on the other side of the ==. This will then simply be a 2 == 2, which will return true.
    D. false, the === is checking strict equality, meaning it checks if the two values are equal without any type conversion whatsoever. Due to 2 being an integer and '2' being a string they will not be equal in the stict equality sense because of the different types they are within.
    E. false, true will be converted into its numerical value of 1 and then the equality will be checked, 1 == 2 which will return false.
    F. true, the Boolean conversion will always return true for a non-empty string as well as anything that is not 0 so in this case the Boolean(2) will return true. Thus the stict equality is checking if true === true which they are both the same so we get a true returned.
15. The == is checking equality and takes into account any type conversions if necessary so the values must be true even if it takes some sort of type conversion to get there it will still return true when using ==. The === is instead checking strict equality which checks equality without any type conversions taken into account so the values must match and the types in order to return a true from ===.
16. See part1b-question16.js for answer.
17. The result will be '[ 2, 4, 6 ]'. To start off within modifyArray the newArr is declared and initialized as empty. Within the for loop is when it gets interesting, when `newArr.push(callback(array[i]));` is called that will be essentially passing the value of `array[i]` into the doSomething function since that was passed into the modifyArray function as the callback parameter. This callback will then take whatever value held within the passed in array at index i and multiply it by 2, returning the result back into the for loop to be pushed onto the newArr. This will continue for each iteration of the for loop and so when the newArr is returned it will go from starting at `[1,2,3]` to being `[2,4,6]`. 
18. See part1b-question18.js for answer.
19. The output is '1 \n 4 \n 3 \n 2'. This happens due to the timeout added to 3 and 2, 2 being a full second and 3 just long enough for 4 to be printed out before it. 